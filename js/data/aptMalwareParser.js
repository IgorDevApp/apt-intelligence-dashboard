/**
 * APT Intelligence Dashboard - APTMalware Data Parser
 * 
 * Parses malware sample data from the APTMalware repository.
 * This data provides malware hashes (IOCs) associated with APT groups.
 * 
 * Source: https://github.com/cyber-research/APTMalware
 * 
 * @module aptMalwareParser
 * @version 1.0.0
 */

const AptMalwareParser = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const state = {
        data: null,
        parsed: false,
        stats: null
    };

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        url: 'https://raw.githubusercontent.com/cyber-research/APTMalware/refs/heads/master/overview.csv',
        cacheKey: 'apt_dashboard_malware_iocs',
        cacheDuration: 7 * 24 * 60 * 60 * 1000 // 7 days
    };

    // =========================================================================
    // PARSING FUNCTIONS
    // =========================================================================

    /**
     * Parses CSV text into array of objects
     * @param {string} csvText - Raw CSV content
     * @returns {Array} Array of malware sample objects
     */
    function parseCSV(csvText) {
        const lines = csvText.trim().split('\n');
        if (lines.length < 2) return [];

        // Parse header
        const header = lines[0].split(',').map(h => h.trim());
        
        // Parse data rows
        const data = [];
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i];
            if (!line.trim()) continue;

            // Handle CSV properly (fields might contain commas in quotes)
            const values = parseCSVLine(line);
            if (values.length < header.length) continue;

            const row = {};
            header.forEach((col, idx) => {
                row[col] = values[idx] || '';
            });

            // Normalize the data
            data.push({
                id: parseInt(row['ID']) || i,
                country: normalizeCountryCode(row['Country']),
                aptGroup: normalizeAptName(row['APT-group']),
                family: row['Family'] || null,
                status: row['Status'] === 'V' ? 'verified' : 'unverified',
                md5: row['MD5'] || null,
                sha1: row['SHA1'] || null,
                sha256: row['SHA256'] || null,
                source: row['Source'] || null
            });
        }

        return data;
    }

    /**
     * Parses a single CSV line, handling quoted fields
     * @param {string} line - CSV line
     * @returns {Array} Array of field values
     */
    function parseCSVLine(line) {
        const values = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                values.push(current.trim());
                current = '';
            } else {
                current += char;
            }
        }
        values.push(current.trim());

        return values;
    }

    /**
     * Normalizes country name to ISO code
     * @param {string} country - Country name
     * @returns {string} ISO 2-letter code
     */
    function normalizeCountryCode(country) {
        const countryMap = {
            'china': 'CN',
            'russia': 'RU',
            'iran': 'IR',
            'north korea': 'KP',
            'dprk': 'KP',
            'pakistan': 'PK',
            'india': 'IN',
            'vietnam': 'VN',
            'usa': 'US',
            'united states': 'US',
            'israel': 'IL',
            'unknown': 'XX'
        };

        const normalized = country.toLowerCase().trim();
        return countryMap[normalized] || country.toUpperCase().substring(0, 2);
    }

    /**
     * Normalizes APT group names for matching
     * @param {string} name - APT group name
     * @returns {string} Normalized name
     */
    function normalizeAptName(name) {
        if (!name) return '';
        // Normalize "APT 1" to "APT1", etc.
        return name.trim().replace(/APT\s+(\d+)/gi, 'APT$1');
    }

    /**
     * Computes statistics from the parsed data
     * @param {Array} data - Parsed malware data
     * @returns {Object} Statistics object
     */
    function computeStats(data) {
        const stats = {
            totalSamples: data.length,
            verifiedSamples: 0,
            uniqueAptGroups: new Set(),
            uniqueFamilies: new Set(),
            byCountry: {},
            byAptGroup: {},
            byFamily: {}
        };

        data.forEach(sample => {
            // Count verified
            if (sample.status === 'verified') {
                stats.verifiedSamples++;
            }

            // Track unique groups
            if (sample.aptGroup) {
                stats.uniqueAptGroups.add(sample.aptGroup);
            }

            // Track unique families
            if (sample.family) {
                stats.uniqueFamilies.add(sample.family);
            }

            // Count by country
            if (sample.country) {
                stats.byCountry[sample.country] = (stats.byCountry[sample.country] || 0) + 1;
            }

            // Count by APT group
            if (sample.aptGroup) {
                stats.byAptGroup[sample.aptGroup] = (stats.byAptGroup[sample.aptGroup] || 0) + 1;
            }

            // Count by malware family
            if (sample.family) {
                stats.byFamily[sample.family] = (stats.byFamily[sample.family] || 0) + 1;
            }
        });

        stats.uniqueAptGroups = stats.uniqueAptGroups.size;
        stats.uniqueFamilies = stats.uniqueFamilies.size;

        return stats;
    }

    // =========================================================================
    // CACHE FUNCTIONS
    // =========================================================================

    /**
     * Gets cached data if available and not expired
     * @returns {Object|null} Cached data or null
     */
    function getCachedData() {
        try {
            const cached = localStorage.getItem(CONFIG.cacheKey);
            if (!cached) return null;

            const { data, timestamp } = JSON.parse(cached);
            const age = Date.now() - timestamp;

            if (age < CONFIG.cacheDuration) {
                console.log(`[AptMalwareParser] Using cached data (age: ${Math.round(age / 60000)} minutes)`);
                return data;
            }
        } catch (e) {
            console.warn('[AptMalwareParser] Cache read error:', e);
        }
        return null;
    }

    /**
     * Saves data to cache
     * @param {Array} data - Data to cache
     */
    function setCachedData(data) {
        try {
            localStorage.setItem(CONFIG.cacheKey, JSON.stringify({
                data: data,
                timestamp: Date.now()
            }));
        } catch (e) {
            console.warn('[AptMalwareParser] Cache write error:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        /**
         * Loads and parses the APTMalware CSV data
         * @param {string} csvText - Optional CSV text (if already loaded)
         * @returns {Promise<boolean>} Success status
         */
        load: async function(csvText) {
            if (state.parsed && state.data) {
                return true;
            }

            try {
                let data;

                if (csvText) {
                    // Parse provided CSV text
                    data = parseCSV(csvText);
                } else {
                    // Check cache first
                    const cached = getCachedData();
                    if (cached) {
                        state.data = cached;
                        state.stats = computeStats(cached);
                        state.parsed = true;
                        console.log(`[AptMalwareParser] Loaded ${cached.length} samples from cache`);
                        return true;
                    }

                    // Fetch from URL
                    console.log('[AptMalwareParser] Fetching data from GitHub...');
                    const response = await fetch(CONFIG.url);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const text = await response.text();
                    data = parseCSV(text);
                    setCachedData(data);
                }

                state.data = data;
                state.stats = computeStats(data);
                state.parsed = true;

                console.log(`[AptMalwareParser] Loaded ${data.length} malware samples`);
                return true;

            } catch (error) {
                console.error('[AptMalwareParser] Load error:', error);
                return false;
            }
        },

        /**
         * Gets all malware samples
         * @returns {Array}
         */
        getData: function() {
            return state.data || [];
        },

        /**
         * Gets statistics
         * @returns {Object}
         */
        getStats: function() {
            return state.stats || {};
        },

        /**
         * Gets malware samples for a specific APT group
         * @param {string} aptName - APT group name
         * @returns {Array} Malware samples
         */
        getByAptGroup: function(aptName) {
            if (!state.data) return [];
            
            const normalized = normalizeAptName(aptName);
            return state.data.filter(sample => {
                const sampleName = sample.aptGroup.toLowerCase().replace(/[\s\-_]/g, '');
                const searchName = normalized.toLowerCase().replace(/[\s\-_]/g, '');
                return sampleName === searchName || sampleName.includes(searchName);
            });
        },

        /**
         * Gets verified IOC hashes for a specific APT group
         * @param {string} aptName - APT group name
         * @returns {Object} Object with md5, sha1, sha256 arrays
         */
        getIOCsForAptGroup: function(aptName) {
            const samples = this.getByAptGroup(aptName);
            const verified = samples.filter(s => s.status === 'verified');

            return {
                total: samples.length,
                verified: verified.length,
                md5: verified.filter(s => s.md5).map(s => s.md5),
                sha1: verified.filter(s => s.sha1).map(s => s.sha1),
                sha256: verified.filter(s => s.sha256).map(s => s.sha256)
            };
        },

        /**
         * Gets malware samples by country
         * @param {string} countryCode - ISO country code
         * @returns {Array}
         */
        getByCountry: function(countryCode) {
            if (!state.data) return [];
            return state.data.filter(s => s.country === countryCode.toUpperCase());
        },

        /**
         * Gets count of malware samples per APT group
         * @returns {Object} APT name to sample count mapping
         */
        getSampleCountByApt: function() {
            return state.stats ? state.stats.byAptGroup : {};
        },

        /**
         * Gets all unique APT groups in the dataset
         * @returns {Array}
         */
        getAptGroups: function() {
            if (!state.data) return [];
            const groups = new Set();
            state.data.forEach(s => {
                if (s.aptGroup) groups.add(s.aptGroup);
            });
            return Array.from(groups).sort();
        },

        /**
         * Gets all unique malware families
         * @returns {Array}
         */
        getMalwareFamilies: function() {
            if (!state.data) return [];
            const families = new Set();
            state.data.forEach(s => {
                if (s.family) families.add(s.family);
            });
            return Array.from(families).sort();
        },

        /**
         * Checks if data is loaded
         * @returns {boolean}
         */
        isLoaded: function() {
            return state.parsed;
        },

        /**
         * Gets URL for the data source
         * @returns {string}
         */
        getSourceUrl: function() {
            return CONFIG.url;
        }
    };
})();

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = AptMalwareParser;
}
